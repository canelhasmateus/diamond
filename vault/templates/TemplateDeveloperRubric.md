# Developer Rubric

<https://github.com/Semalab/developer-skills-matrix/blob/main/rubric/rubric.md>

| Category             | Sub-Category                                        | Beginner                                                                                                                                                                                | Advanced Beginner                                                                                                                                                                                              | Intermediate                                                                                                                                                                                                                                                    | Advanced                                                                                                                                                                                                                                                                                                                           | Expert                                                                                                                                                                                                                                                                                                                                                                                                              |
| -------------------- | --------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| General              | General                                             | A Beginner developer is just getting started.                                                                                                                                           | Advanced Beginners may not be the workhorse of a project but they can provide more value than they require from a dev team.                                                                                    | Intermediate developers can effectively support Advanced Beginner and Beginner developers. They can understand and ask challenging questions about design techniques.                                                                                           | Advanced developers are capable of looking at the bigger picture for engineering challenges and design key components from scratch. They can mentor not just support more junior devs.                                                                                                                                             | Experts can not only design a solution but also see how it interacts with other software. They're capable of acting as force multipliers as well as mentors. While they may not be as “hands on keyboard” as other devs they still know how to code at an incredibly high level.                                                                                                                                    |
|                      | Where they are likely to be found                   | Self-taught developers who are just getting started. Programming or Computer Science students in their first two years of study.                                                        | Developers who have been coding for a few months to a few years.                                                                                                                                               | Most professional software developers.                                                                                                                                                                                                                          | Most Advanced developers fill Tech Lead roles though they can still be found in the frontline of a team.                                                                                                                                                                                                                           | Experts sometimes have “Architect” in their title and are rare and valuable enough to be spread across multiple teams.                                                                                                                                                                                                                                                                                              |
| Communication        | Feedback and Code Reviews                           | Have not learned how to handle constructive feedback professionally. Pull Request comments are low value.                                                                               | Accepts constructive feedback calmly but may need multiple iterations to implement the technical solution. Can catch obvious errors in PRs but may be hesitant to challenge or provide actionable suggestions. | Accepts constructive feedback well and can implement it quickly in and out of code reviews. Provides quality guidance to Advanced Beginners.                                                                                                                    | Accepts constructive feedback with grace and acts on it when appropriate. Provides context-appropriate and actionable feedback to develop ers of all levels. Recognizes their own biases and actively works to correct them. Capable of seeing bugs through reading code in PRs before even pulling down the branch.               | Models a supportive and productive feedback culture. Accepts constructive feedback with grace and acts on it when appropriate. Proactively reaches out for more feedback in areas of lower skill or where previous mistakes were made calling out hotspots for reviewers to focus on.                                                                                                                               |
|                      | Requirements                                        | Requires very detailed step-by-step overviews of requirements. Can carry very small tasks. Cannot estimate time requirements.                                                           | Can implement requirements but may be "to the letter" of acceptance criteria and no more. Will be familiar with just a few areas of a single application. Low quality estimation.                              | Implements requirements both to the letter and spirit of acceptance criteria. Asks good questions during requirements grooming. However they may fall into "Bikeshedding" patterns or require very detailed specifications. Mixed estimation accuracy.          | Frequently provides the organization / project with simpler optimized requirement alternatives. Can communicate organization / project needs to developers and design constraints to users. Can break down large requirements by domain or stack verticals. Good estimation accuracy. Effective at “pushing back” on the Business. | Consistently anticipates the organization’s / project's needs and improves grooming to suit it. Capable of building roadmaps that balance technical efficiency with maximum value. Influences testing strategies to ensure quality. Excellent estimate accuracy. Highly effective at “pushing back” on the Business.                                                                                                |
|                      | Technical Communication                             | Low or incorrect knowledge of technical vocabulary. Explains concepts with textbook definitions without practical backing.                                                              | Can communicate clearly with higher level developers but still struggles to discuss things with non-technical stakeholders. Can help beginners with obvious problems but will defer fairly frequently.         | Beginning to show the ability to discuss technical topics with non-technical stakeholders. Can fluently discuss topics with correct vocabulary. Developing pattern matching and simplification skills.                                                          | Capable of fluently discussing technical topics with simplified and direct vocabulary. Organizes written communication for consumption by the intended audience. Expert pattern matcher but may over-simplify and miss details.                                                                                                    | Able to discuss technology with the broadest range of stakeholders from the form of simplified executive presentations to in-depth debates with solution architects on the details of tool selection. Passively builds knowledge and insight in more junior team members.                                                                                                                                           |
| Core Software Skills | Data Structures                                     | Understands simple control flow and some basic collections. May fit incorrect but familiar data structures to far too many problems.                                                    | Understands most control flow and collections. Can sometimes tell when an algorithm can be improved but probably won't know how. Follows established patterns but cannot chart a new course.                   | Can optimize advanced beginner code call out reasons for performance deficiencies and understands the basics of how data access and networking calls can affect performance.                                                                                    | Strong understanding of data structures and rarely makes degenerative code mistakes. Intimately understands data access and network calls. Knows hot spots where technical debt lives and must be addressed at a solution level.                                                                                                   | Can implement high-tier algorithms with maximum performance. Understands how to build rube-goldberg/code golf structures - and uses this knowledge to avoid them at all costs. Strong understanding of popular and valuable design patterns.                                                                                                                                                                        |
|                      | Style and Semantics                                 | Methods are typically too large with verbose or otherwise unuseful names. Can imitate patterns or styles but often incorrectly.                                                         | Will think about how to solve a problem generically before worrying about syntax. Will ask naive but still-useful questions. Will require reinforcement to follow established patterns.                        | Uses inoffensive function and variable names as a rule. Has developed opinions about coding styles and languages and can speak about their background. Highly complex code may still need a heavy hand from Advanced or Expert developers to make it beautiful. | Has a knack for using agreeable function and variable names that other developers use without complaint. Deviates from style when appropriate but is an advocate for shared approaches. Capable of implementing complex code and explaining it to another developer for validation.                                                | Consistently drives high-level vision for style with high team buy-in. Influences entire codebases while writing a subset of the code. Accepts feedback and follows along when joining a new team with mature practices - even if those practices don't match the Developer's own.                                                                                                                                  |
|                      | General                                             | Can implement greedy solutions to algorithm problems but misses corner cases. No/ low understanding of unit testing. Only familiar with a small number of frameworks some only by name. | Can implement basic solutions that may not be optimal and catch simple corner cases. Will build tests if assigned but needs strong patterns to build off of. Strongly familiar with at least one framework.    | Implements medium complexity functionality after a team discussion and can be trusted with complexity given enough detail from Senior team members. Code is generally complete and can be trusted with both unit and "Dev Testing" tasks.                       | May be the first boots on the ground for a new feature creating scaffolds for intermediate developer s to follow. Understands the frameworks in use across the entire stack and has dabbled enough outside of the toolset to know what's good and what's not. Has a plan for how to improve whatever the team's next project is.   | Can organize and design critical-path features for the organization / project and its users. Has a wide variety of experience outside of a project's selected toolset and understands the life-and-hype cycle of new frameworks at a deep level. Has a plan to make sure the entire team's skills will be used to their maximum potential for the next project even if it doesn't build their resume quite as much. |
| Infrastructure       | Source Control and Application Lifecycle Management | Can clone a git repository but unfamiliar with branching and little or no knowledge of keeping work tracking organized.                                                                 | Understands branching strategies but generally just for a single team. Can follow strong work tracking practices when provided.                                                                                | Understands branching strategies from a couple of teams and approaches and can provide pros and cons. Understands work tracking and adheres to standards. Able to provide good feedback and opinions for improving team processes.                              | Knows the pros and cons of multiple branching strategies but may still try and force an inappropriate one on a certain product. Understands work tracking systems and how to passively communicate with the organization / project through them. An advocate for improved process.                                                 | Capable of creating a cohesive branching strategy that serves the need of both the development team and users. Enhances the ALM experience with rich tagging versioning and automated documentation generation. Can provide valuable and cross-team guidance on best practices.                                                                                                                                     |
|                      | Design and Deployment                               | Will require significant help to set up a typical project. Little understanding of underlying hardware or the particulars of tool selection.                                            | Will encounter issues if the "happy path" of environment setup hits a snag. Will not understand environment progression or the details of how components fit together.                                         | Can use well-developed Google-Fu to sort through issues and environmental differences. Understands environment progression for lower environments and has optimized their setup for debugging.                                                                  | Has set up instructions for projects and knows common pitfalls. May be familiar with containers. Capable of designing simple DevOps pipelines and fully understands environment progression for product(s) they work on.                                                                                                           | Understands almost every aspect of the infrastructure required for a solution and has optimized them for performance and simplicity. Can author rich DevOps pipelines even if their knowledge may not match a dedicated professional.                                                                                                                                                                               |

___

<https://sijinjoseph.com/programmer-competency-matrix/>

|

#### Computer Science

\|  |  |  |  |  |
\| --- | --- | --- | --- | --- | --- |
\|  | 2n (Level 0) | n2 (Level 1) | n (Level 2) | log(n) (Level 3) | Comments |
\| data structures | Doesn’t know the difference between Array and LinkedList | Able to explain and use Arrays, LinkedLists, Dictionaries etc in practical programming tasks | Knows space and time tradeoffs of the basic data structures, Arrays vs LinkedLists, Able to explain how hashtables can be implemented and can handle collisions, Priority queues and ways to implement them etc. | Knowledge of advanced data structures like B-trees, binomial and fibonacci heaps, AVL/Red Black trees, Splay Trees, Skip Lists, tries etc. |  |
\| algorithms | Unable to find the average of numbers in an array (It’s hard to believe but I’ve interviewed such candidates) | Basic sorting, searching and data structure traversal and retrieval algorithms | Tree, Graph, simple greedy and divide and conquer algorithms, is able to understand the relevance of the levels of this matrix. | Able to recognize and code dynamic programming solutions, good knowledge of graph algorithms, good knowledge of numerical computation algorithms, able to identify NP problems etc. |  |
\| systems programming | Doesn’t know what a compiler, linker or interpreter is | Basic understanding of compilers, linker and interpreters. Understands what assembly code is and how things work at the hardware level. Some knowledge of virtual memory and paging. | Understands kernel mode vs. user mode, multi-threading, synchronization primitives and how they’re implemented, able to read assembly code. Understands how networks work, understanding of network protocols and socket level programming. | Understands the entire programming stack, hardware (CPU + Memory + Cache + Interrupts + microcode), binary code, assembly, static and dynamic linking, compilation, interpretation, JIT compilation, garbage collection, heap, stack, memory addressing… |  |
|

#### Software Engineering

\|  |  |  |  |  |
\|  | 2n (Level 0) | n2 (Level 1) | n (Level 2) | log(n) (Level 3) | Comments |
\| source code version control | Folder backups by date | VSS and beginning CVS/SVN user | Proficient in using CVS and SVN features. Knows how to branch and merge, use patches setup repository properties etc. | Knowledge of distributed VCS systems. Has tried out Bzr/Mercurial/Darcs/Git |  |
\| build automation | Only knows how to build from IDE | Knows how to build the system from the command line | Can setup a script to build the basic system | Can setup a script to build the system and also documentation, installers, generate release notes and tag the code in source control |  |
\| automated testing | Thinks that all testing is the job of the tester | Has written automated unit tests and comes up with good unit test cases for the code that is being written | Has written code in TDD manner | Understands and is able to setup automated functional, load/performance and UI tests |  |
|

#### Programming

\|  |  |  |  |  |
\|  | 2n (Level 0) | n2 (Level 1) | n (Level 2) | log(n) (Level 3) | Comments |
\| problem decomposition | Only straight line code with copy paste for reuse | Able to break up problem into multiple functions | Able to come up with reusable functions/objects that solve the overall problem | Use of appropriate data structures and algorithms and comes up with generic/object-oriented code that encapsulate aspects of the problem that are subject to change. |  |
\| systems decomposition | Not able to think above the level of a single file/class | Able to break up problem space and design solution as long as it is within the same platform/technology | Able to design systems that span multiple technologies/platforms. | Able to visualize and design complex systems with multiple product lines and integrations with external systems. Also should be able to design operations support systems like monitoring, reporting, fail overs etc. |  |
\| communication | Cannot express thoughts/ideas to peers. Poor spelling and grammar. | Peers can understand what is being said. Good spelling and grammar. | Is able to effectively communicate with peers | Able to understand and communicate thoughts/design/ideas/specs in a unambiguous manner and adjusts communication as per the context | This is an often under rated but very critical criteria for judging a programmer. With the increase in outsourcing of programming tasks to places where English is not the native tongue this issue has become more prominent. I know of several projects that failed because the programmers could not understand what the intent of the communication was. |
\| code organization within a file | no evidence of organization within a file | Methods are grouped logically or by accessibility | Code is grouped into regions and well commented with references to other source files | File has license header, summary, well commented, consistent white space usage. The file should look beautiful. |  |
\| code organization across files | No thought given to organizing code across files | Related files are grouped into a folder | Each physical file has a unique purpose, for e.g. one class definition, one feature implementation etc. | Code organization at a physical level closely matches design and looking at file names and folder distribution provides insights into design |  |
\| source tree organization | Everything in one folder | Basic separation of code into logical folders. | No circular dependencies, binaries, libs, docs, builds, third-party code all organized into appropriate folders | Physical layout of source tree matches logical hierarchy and organization. The directory names and organization provide insights into the design of the system. | The difference between this and the previous item is in the scale of organization, source tree organization relates to the entire set of artifacts that define the system. |
\| code readability | Mono-syllable names | Good names for files, variables classes, methods etc. | No long functions, comments explaining unusual code, bug fixes, code assumptions | Code assumptions are verified using asserts, code flows naturally – no deep nesting of conditionals or methods |  |
\| defensive coding | Doesn’t understand the concept | Checks all arguments and asserts critical assumptions in code | Makes sure to check return values and check for exceptions around code that can fail. | Has his own library to help with defensive coding, writes unit tests that simulate faults |  |
\| error handling | Only codes the happy case | Basic error handling around code that can throw exceptions/generate errors | Ensures that error/exceptions leave program in good state, resources, connections and memory is all cleaned up properly | Codes to detect possible exception before, maintain consistent exception handling strategy in all layers of code, come up with guidelines on exception handling for entire system. |  |
\| IDE | Mostly uses IDE for text editing | Knows their way around the interface, able to effectively use the IDE using menus. | Knows keyboard shortcuts for most used operations. | Has written custom macros |  |
\| API | Needs to look up the documentation frequently | Has the most frequently used APIs in memory | Vast and In-depth knowledge of the API | Has written libraries that sit on top of the API to simplify frequently used tasks and to fill in gaps in the API | E.g. of API can be Java library, .net framework or the custom API for the application |
\| frameworks | Has not used any framework outside of the core platform | Has heard about but not used the popular frameworks available for the platform. | Has used more than one framework in a professional capacity and is well-versed with the idioms of the frameworks. | Author of framework |  |
\| requirements | Takes the given requirements and codes to spec | Come up with questions regarding missed cases in the spec | Understand complete picture and come up with entire areas that need to be speced | Able to suggest better alternatives and flows to given requirements based on experience |  |
\| scripting | No knowledge of scripting tools | Batch files/shell scripts | Perl/Python/Ruby/VBScript/Powershell | Has written and published reusable code |  |
\| database | Thinks that Excel is a database | Knows basic database concepts, normalization, ACID, transactions and can write simple selects | Able to design good and normalized database schemas keeping in mind the queries that’ll have to be run, proficient in use of views, stored procedures, triggers and user defined types. Knows difference between clustered and non-clustered indexes. Proficient in use of ORM tools. | Can do basic database administration, performance optimization, index optimization, write advanced select queries, able to replace cursor usage with relational sql, understands how data is stored internally, understands how indexes are stored internally, understands how databases can be mirrored, replicated etc. Understands how the two phase commit works. |  |
|

#### Experience

\|  |  |  |  |  |
\|  | 2n (Level 0) | n2 (Level 1) | n (Level 2) | log(n) (Level 3) | Comments |
\| languages with professional experience | Imperative or Object Oriented | Imperative, Object-Oriented and declarative (SQL), added bonus if they understand static vs dynamic typing, weak vs strong typing and static inferred types | Functional, added bonus if they understand lazy evaluation, currying, continuations | Concurrent (Erlang, Oz) and Logic (Prolog) |  |
\| platforms with professional experience | 1 | 2-3 | 4-5 | 6+ |  |
\| years of professional experience | 1 | 2-5 | 6-9 | 10+ |  |
\| domain knowledge | No knowledge of the domain | Has worked on at least one product in the domain. | Has worked on multiple products in the same domain. | Domain expert. Has designed and implemented several products/solutions in the domain. Well versed with standard terms, protocols used in the domain. |  |
|

#### Knowledge

\|  |  |  |  |  |
\| tool knowledge | Limited to primary IDE (VS.Net, Eclipse etc.) | Knows about some alternatives to popular and standard tools. | Good knowledge of editors, debuggers, IDEs, open source alternatives etc. etc. For e.g. someone who knows most of the tools from Scott Hanselman’s power tools list. Has used ORM tools. | Has actually written tools and scripts, added bonus if they’ve been published. |  |
\| languages exposed to | Imperative or Object Oriented | Imperative, Object-Oriented and declarative (SQL), added bonus if they understand static vs dynamic typing, weak vs strong typing and static inferred types | Functional, added bonus if they understand lazy evaluation, currying, continuations | Concurrent (Erlang, Oz) and Logic (Prolog) |  |
\| codebase knowledge | Has never looked at the codebase | Basic knowledge of the code layout and how to build the system | Good working knowledge of code base, has implemented several bug fixes and maybe some small features. | Has implemented multiple big features in the codebase and can easily visualize the changes required for most features or bug fixes. |  |
\| knowledge of upcoming technologies | Has not heard of the upcoming technologies | Has heard of upcoming technologies in the field | Has downloaded the alpha preview/CTP/beta and read some articles/manuals | Has played with the previews and has actually built something with it and as a bonus shared that with everyone else |  |
\| platform internals | Zero knowledge of platform internals | Has basic knowledge of how the platform works internally | Deep knowledge of platform internals and can visualize how the platform takes the program and converts it into executable code. | Has written tools to enhance or provide information on platform internals. For e.g. disassemblers, decompilers, debuggers etc. |  |
\| books | Unleashed series, 21 days series, 24 hour series, dummies series… | Code Complete, Don’t Make me Think, Mastering Regular Expressions | Design Patterns, Peopleware, Programming Pearls, Algorithm Design Manual, Pragmatic Programmer, Mythical Man month | Structure and Interpretation of Computer Programs, Concepts Techniques, Models of Computer Programming, Art of Computer Programming, Database systems , by C. J Date, Thinking Forth, Little Schemer |  |
\| blogs | Has heard of them but never got the time. | Reads tech/programming/software engineering blogs and listens to podcasts regularly. | Maintains a link blog with some collection of useful articles and tools that he/she has collected | Maintains a blog in which personal insights and thoughts on programming are shared |  |

- [](https://twitter.com/intent/tweet?url=https://sijinjoseph.netlify.app/programmer-competency-matrix/\&text=Programmer%20Competency%20Matrix)
- [](https://www.facebook.com/sharer.php?u=https://sijinjoseph.netlify.app/programmer-competency-matrix/\&t=Programmer%20Competency%20Matrix)
- [](mailto:?subject=Programmer%20Competency%20Matrix\&body=https://sijinjoseph.netlify.app/programmer-competency-matrix/)
- [](https://www.linkedin.com/shareArticle?url=https://sijinjoseph.netlify.app/programmer-competency-matrix/\&title=Programmer%20Competency%20Matrix)

const code\_highlighting=true;const isSiteThemeDark=false;const search\_config={"indexURI":"/index.json","minLength":1,"threshold":0.3};const i18n={"no\_results":"No results found","placeholder":"Search...","results":"results found"};const content\_type={'post':"Posts",'project':"Projects",'publication':"Publications",'talk':"Talks",'slides':"Slides"}; <div class="search-hit" id="summary-{{key}}"> <div class="search-hit-content"> <div class="search-hit-name"> <a href="{{relpermalink}}">{{title}}</a> <div class="article-metadata search-hit-type">{{type}}</div> <p class="search-hit-description">{{snippet}}</p> </div> </div> </div>

Powered by the [Academic theme](https://sourcethemes.com/academic/) for [Hugo](https://gohugo.io).
