# ProblemFrames

Examples

* [[OnLeet1020]] can also be implemented differently, by constructing a [[AdjacencyMatrix]] for each of the islands, and exponentiating several times, simulating [[RandomWalks]].
    By doing it enough times to reach any border, we can confidently state that any not-reached island is unreachable. Of course, this approach is not algorithmically efficient.


___


An important part of solving problems is looking at them the right way.

* The read-list situation becomes easier to manage when looking at it as a stream.
* Thinking of it as a stream lends itself to be handled just like any other stream.
    Thinking of it as an application of data engineering buys us the scheduling, composition and error handling of the processes in the space.
* The same goes for the flowtime situation: Thinking of it as a scheduling problem looks like the right abstraction since Gantt charts fit these visualizations perfectly.
* The same goes for the whole Gnosis mentality. Working with text and locally buys us the simplicity, flexibility and ease of use necessary to embed this as part of our life, instead of being a source of stress and emotional pain that most chores give us.


Its easy to easy to think about it and realize it post-hoc, after two given possibilities are presented and compared, and one is declared as a winner.
    However, how do we go about finding out these delimitations in a structured manner?
    Sure, Noticing patterns while practing helps. However, this doesn't seen very scientific to me... [[expand]]

___

