# 2022-04-03



Port forward

Can be done in the router.
    . Ugly, 

iptables
     

    

nat



transparent proxying


why don't we just run the app in port 80?
    . ports 0 to 1024, these are system ports, 
    . cant listen on then unless root
        -> Security concerns. 

insert rows in the nat table. 
    . "please forward to me , on this other port"
    . uses iptables -> System call , need sudo 
        -> sudo iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 192.168.254.47:8080

    |> needs to be a ip, cant be dns
when routing to another machine, we need to use maskarade 
    . sudo iptables -t nat -A postrouting -p tcp --dport 80 -j MASQUERADE --to-destination ....

these are session only. to persist,  need to use apt-get install iptables-persistent

clearing
    sudo iptables -t nat -F
    
# 


your router is the one who has the public ip address
    . How does it knows to forward the requests?

    . There are many, for example
        .. Port Forwarding
    
Port Forward is a table configured inside the router, which allows it to forward the requests
    . However, your ip must be static , because the ip in the table is static. 


# 

Network Address Translation
    
    Maps a ip address to another ip address
        ( or a ip_address:port pair to another one )
    
    Originally designed to solve the only 4bi ipv4 devices

    not only application
        . 

    

    devices inside the same network can communicate directly by finding each other mac addresses using arp


check if its in the same subnet, does an arp request 
else, it calls its default gateway
    when rounting a request, the router will:
        check if its an unroutable ip addresses.

if 
router vs switches?


can use to do more things
    . Instead of having root access to listen on port 80.

    . load balancing: takes the packets coming, and create a virtual ip addresses ( VIP ). the vip gets an entry in the nat table  
        
DNS 
    . Can point to ip:ports via SRV records


# 
ARP

Maps Ip addreses to mac addresses 

Why?
        
        we need mac to send frames ( layer 2 )

        Most of the time, we know the ip address , but not the mac. 
        
        this process is expensive, so its cached locally, in an ARP table 

Network Frames
    
    encapsules the ip packet

    ![](2022-04-03-12-13-24.png)
    
    what if the target ip address does not fall inside the local network?

    in this case , the application sends an arp request looking for a default gateway. then, it builds the network frame and sends it. 


# 

Osi model 
 
open system interconnections


layer 7 applicatoin
layer 6 presentatoin -> Encrypt if necessary
layer 5 Session -> Establish session ; tag it. 
Layer 4 Transport -> Add ports/seq ; Break into segments;
Layer 3 Network -> Adds IP ; Now, called a packet. 
Layer 2 Data Link -> Breaks packets and adds the Target Mac ADdresses  ; Now Called Frames, have basic error detection 
Layer 1 Physical -> Tranforms into 1 and 0, into electric / optical / radio waves

frames are fixed size 
frames are received by everyone in the same broadcast domain, but the network card just discards it ( unless its a broadcast or multicase addressed) . It can be configured to not do so, and forward every packet: This is called promiscuous mode. 

where does the tcp buffer enter her?? [[expand]]


# 

TCP Tunneling is the proccess of encapsulating content from a protocol A to a protocol B , usually because A is unnavailably. 
    
    .. Isn't this just IPSEC?
    .. Or proxying 

Applications

    Local port forwarding tunnel
    Reverse Port Forwarding tunnel
    SOCKS proxy ( dynamic port )

This can cause TCP meltdown ( tcp over tcp )
    tcp isn't a lightweight protocol 
        congestion control, retransmission, garantee delivered, checksumming, 
    doing a tcd inside a tcp inside a tcp ... can slowdown everything


# 


ARP 

For some time now i have this conception of what a "learning" workflow would ideally look like  


# 


Earlier on, i was trying to use other "specialized" apps , such as roam and obsidian, but i kept hitting this barrier of operational friction ; 
Had to remap a lot of things, workaround lack of support ; I went to the length of coding an entire plugin to be able to do my shortcuts
(https://github.com/tgrosinger/leader-hotkeys-obsidian/pull/19), which was merged yesterday btw.

In summary, this operational friction isn't good, and from my findings, there wouldn't be that much great gains anyway. Any that might exists can be acessed by using the app in a read-only way, while letting the editor do the write-edit heavy part.

With this out of the way, i could focus better on the note-taking content, per se

___ 

In regards to note-taking, the approach i've settled down on was a incremental one: Every day i create a single new note , with the date. In this note i just write down streams of thought, with very little structure. 
When i "feel like it", i just go over these previous day streams, and pick them apart for the good bits. The connections and structured content comes about in only a second moment : this is something that i would consider key. 

For the results, i feel like taking a more structured ( but still organic ) approach to learning makes me more mindful of the process. 
Being able to spot those 'gems' that come into our minds, which we know are good content but would not otherwise solidify. 
The connection-part thing is very interesting also - Seems like i'm always on the lookout for parallels and analogies now , which i consider a good thing. 


All in all , its been pretty good, would def recommend. 

The key points should be like:
    1 . Overcome the operational friction by incorporating it inside my editors
    2 . Having triggers for doing it
    3 . Don't stressing about immediately producing structured content.

As an exemplification of the above concepts:
    1 .  I'm using foam / dendron inside vscode , so writing and editing feels way easier
    2 . I developed a web page that gets brought whenever i hit a new tab - This page picks 5 random articles from my readlist and displays them to me. 
    3 . Having the daily stream of thought file. 


Some great things about having a "simple"  workflow is that:
    .  Easily versionable. This gives me a lot of security , knowing that its always backed up somewhere and i can just undo whatever / whenever.
    . Its flexible: I incorporated my read lists into it ( the lists inside the /other folder. ), and since its text, i can interact with it via custom scripts easily. Currently, i'm able to write down basically every page i visit using autohotkeys, and mark it down as read using python. Also using scripts to create the web page.

For a time now, i've been thinking about what would an ideal learning workflow be:
    . I  would have a structured "Knowledge Sources", such as rss feeds and other read lists
    . I would have some kind of way to process and archive the golden nuggets 
    . I would have some kind of way to go over these archives, re-learning them. A big issue i had recently was just forgetting things. Feels like for every two things i learn i forgot about another one. 

Up until now i was able to structure only the first one. I feel like zettelkasten has been a good way of implementing the second one. I plan to implement some kind of active-recall or spaced-repetition routines to re-learn what i wrote down. 
And i kinda get excited about other possibilites - Can i integrate this with technologies such as GPT3, as to have a *very* personal assistant? 
